# Intro-to-HTML-CSS
These are the basics of web development.
![image](https://github.com/McengwaAyanda/Intro-to-HTML-CSS/assets/81769629/d63cd86e-6bc2-4196-b8a7-a25cb3d26007)

# HTML Introduction
HTML is a standard markup language for creating web pages.
HTML describes the structure of the web page
HTML consists of a series of elements that tell the browser how to display the content.
HTML elements labels pieces of elements such as "Headings", "paragraphs", "Links" etc.

# Text Formatting
HTML uses tags, which are enclosed in less-than and greater-than symbols, to mark different elements.
HTML tags come in two types: opening tags and closing tags. e.g the opening tag for a paragraph is <p> , and the closing tag is </p>
These tags work together to define elements, which are like packages containing content. some elements, like paragraph contain require both opening and closing tags
while others do not
The HTML document is basically a bunch of HTML elements nested inside each other.
The browser pays attention to this structure and builds a big family tree that shows how everything is related. it is called a Document Object Model (DOM) tree.
It is important to pay attention to where we open and close our HTML tags and how we nest elements within each other. this helps convey meaning about the content and interfaces
![image](https://github.com/McengwaAyanda/Intro-to-HTML-CSS/assets/81769629/03e3822d-3bf7-44ba-8991-6c7bb5075b3f)

# HTML Headlines
Web pages usually contains headlines, headings, subheading when dealing with lengthy text, these elements serve the purpose of dividing the content to smaller digestable chunks.
The HTML elements used for marking up headlines come in 6 different types: h1, h2, h3, h4, h5 and h6. when view in a browser, each headline has a distinct visual effect.
These elements convey a sense of hierarchy in how the browser interprets and communicates about the page.
The h1 is the largest and most prominent, while the h6 is the smallest and least attention grabbing. The other elements fall somewhere in between in terms of prominance and importance.
The choice of the headline level is not based on appearance but on its meaning. It makes sense to use h1 for the main title and h2 for the subheading after the title.
The hierarchical system of the headlines gives meaning browser, distinguishing what is most important to what is less important, It also ensures that all article headlines share the same type, h2,
which is crucial for screen reader users who rely on consistent hierarchical information to navigate the page.
![image](https://github.com/McengwaAyanda/Intro-to-HTML-CSS/assets/81769629/d15bae08-ac7f-4f2d-8959-fbbbeaaea439)


# HTML Bold and Italics
There are 4 elements in HTML that allow us to mark text as bold or italicized. Two of them '<em>' and '<strong>', convey meaning  and serve a language-related purpose. The other two, '<i>' and '<b>' do not
carry any specific meaning and are solely for visual styling 
![image](https://github.com/McengwaAyanda/Intro-to-HTML-CSS/assets/81769629/548e971c-3514-4747-9472-6bb4f1204969)


# HTML lists
There are 3 types of lists: Ordered list, unordered list and definition list

 # Unordered list
Unordered list are the most commonly used type. each item in the list is enclosed in an <li> element, which represent a list item.
To define the entire list and specify its type, we wrap all the items in a <ul> element, which stands for unordered list.
If you want to make our code more readable, indent the list items by adding some space or tabs before each other. However, this indentation does not affect how this page looks.
The default appearance of the list markers is determined byt the browser, but we choose <ul> not solely for its appearance. It is the appropriate choice for conveying meaning and we can use CSS to change the look.
![image](https://github.com/McengwaAyanda/Intro-to-HTML-CSS/assets/81769629/830459de-7afd-48a3-a3b9-95b0674e4214)
 # Ordered list
 Ordered list is similar to unordered list but with slight difference. Instead of using <ul> to wrap the list items, we use <ol>.
 The term 'ol' stands for ordered list, indicating that the is a specific order to the items in the list.
 ![image](https://github.com/McengwaAyanda/Intro-to-HTML-CSS/assets/81769629/6899d211-dd42-4c31-95a7-3c72bfb646a4)
  # Definition list
Definition list is used when we want to create a lits that resembles a key-value pair in computer science. Instead of just items, we have terms and thier corresponding descriptions.
To create a definition list, we use specific elements. The term or key is enclosed in a <dt>tag, which stands for definition term. The description or value is enclosed in a <dd>tag, which stands for definition description.
The entire list is wrapped in a <dl>tag representing the definition list. interestingly, the <dd>tags and <dt>tag are placed side by side without any additional wrapper around them.
![image](https://github.com/McengwaAyanda/Intro-to-HTML-CSS/assets/81769629/cb371c86-6a9d-4752-b3e5-34f88ff69824)

# HTML Quotes
These 2 elemnts, <cite> and <blockquote>, serve a semantic purpose. they inform other computers, "Hey this is what it is", additionally, they provide a convenient way to apply custom styling.
The important thing is that elements should be nested within each other in a way that makes sense.
![image](https://github.com/McengwaAyanda/Intro-to-HTML-CSS/assets/81769629/9f75d645-d44f-47f7-8e51-62d236ae8388)

To make things easier, we can use <q> element in HTML which stands for quote.  by using this element the browser will add the appropriate quote marks for us.
Some HTML elements, like <i>, <strong>, <b> and <em> are called inline, because they are meant to wrap around phrases of text that are inline with other content.
There are certain elements in HTML known as block-level elements, like block quotes, paragraphs and unordered lists. These elements essentially  create separate blocks on the page.
Some elements serve as markers for something that is part of a larger enitty, while others represent the larger enitity itself.
HTML attributes provide additional information to HTML elements. in this case, datetime attribute allows us to specify the date or time in a format that computers can understand. We write it like this: <time datetime= "2025-05-02"> May 02, 2025 </time>.
The format of the date within the date time has to be specific. Dates and times have a special format that machines can understand, we need to use that format.
Machines prefer a highly standardized format, and we can also indicate times using the time element. The machine-readable version prefers numbers in the 24-hour clock format and we can choose whether to include seconds and fractions of a second or not.
You can also combine the time and date using the datetime attribute. first you include the date than the time. you have a couple of options for separating them, you can use a T or leave a space.
There are various ways to format the machine-readable time, they are all acceptable and correct, and they apply to many programming languages.

# HTML code, pre and br
By default, code is treated as an inline element, meaning that it remains part of the sentence its in.
The 'Br' element is a simple tag without the opening or closing tag. It does not contain anything inside it, it just indicates where the line needs to break
Pre and code are often combined to display a code block with proper indentation. we have the code, br and pre working together, and these elements are handy for conveying the structure and appearance of code, as well as other types of contents.

# HTML Superscripts, Subscripts and Small text
Superscripts, subscripts and small text can be used where you need to mark up certain bits of content as having a different meaning than the rest.
Subscripts are characters that are set below the normal baseline for text, while Superscript are characters that are set above the normal baseline for text.
Small, sub, and sup are the elements that can help you get the details right when it comes to typography and conveying the full meaning of your content.

# Debugging and troubleshooting HTML code
If you are ever about the markup to use, visit other websites with similar content and use the developer tools to find out which elements they used. it is especially useful if the website was built by a team we admire because studying others' work helps understand how to structure your own HTML

# HTML Attributes
When looking at global attributes in HTML that work universally, we will look at 4 highly useful ones.
The class attribute is the most commonly used. it allows us to assign a reusable name to any element, which can than be styled using CSS, for all elements sharing that class.
Another popular attribute is the Id. it is similar to the class attribute, but we can use unique names once on the entire HTML page. IDs can be used for CSS targeting, but are more specific and can sometimes cause issues.
IDs come in handy when we need to address specific elements in Javascript or targeted links. The uniqueness of an ID name ensures that there will always be one element with that ID, making it useful for interacting with Javascript or links.
Class and ID attributes provide a way to name HTML elements and reference them to other parts of the code stack.
HTML offers many attributes that enhance user interaction and provide hooks into browser power. These attribute such as 'content editable' allow interaction with the screen, keyboard, and assistive devices. They facilitate the editing capability within the browser.
The 'dir' attribute explicitly indicates the direction which the text flows using "LTR" for Left-To-Right and "RTL" for Right-To-Left scripts. These attributes "lang" and "dir" are considered global attributes and can be used on any HTML element.

# Aria Roles
Aria roles are like extra HTML attributes that we can add to HTML elements to make them more meaningful and help browsers understand what they represent. 
Aria roles come into play when we want to provide essential information to assistive technologies like screen readers, braille displays and magnifiers to ensure a website is fully accessible.
The accessibility tree is like a companion to the DOM tree, which the browser creates from the websites content. while the DOM tree represents the HTML structure, the accessibility tree is crucial for assistive devices like screen readers.
When we look at the accessibility tree, we can see that it treats the content as separate text containers. this results in poor experience, such as each letter being read individually. to improve this we use Aria.
Aria is a powerful tool that greatly enhance web accessibility and is worth exploring further. Aria provides the necessary tools to make your site accessible to everyone.

# Formatting HTML
In HTML comments are inserted by typing "<!-- comments -->". These comments are disregarded by the browser, but code editors like Notepad++ can display commented code or remarks in a grayed-out fashion. 
This feature helps developers quickly identify when code is commented out and prevents any confusion when it does not function as expected.
People used to capitalize all their HTML elements, but as HTML evolved, the web industry embraced the idea of using lowercase letters for everything. The broswer isn't affected either way.
Some HTML elements are short like <i> and <p> while some are long like <article> and <video>. The reason for this is that when HTML was first created, computer scientist were focused on optimizing file size due to limited computer resources. 
As technology advanced and computer memory expanded, it became less crucial to save a few characters and more important to prioritize code readability and understanding for humans. Hence, newer HTML elements started using complete words instead of abbriviations. This change made it easier for english-speaking people to comprehend the code.
Nowadays, the length of an element can give us a clue about how long it has been in existance.
A bunch of elements in this course and most of them have a opening and closing tag. The newer HTML elements always have both tags, but for some of the older elements the are no closing tags.

# Unusual characters
The symbols < > and & are important characters in HTML.
In the demo, we used something called character entity in HTML. These entities are formatted like this: an ampersand, ashort code and a semicolon. When we use these in HTML files, they are converted into the specific characters we want. we applied this technique to replace every instance of greater-than or less-than symbols with their corresponding character entities.

#HTML Navigation and linking

# HTML Links
When we want to create a link, we use the "A" element, which stands for "anchor". to do this, we need to add a "href" attribute with a URL enclosed in quotes. This URL is where the link will take us. 
The term "href" stands for "HyperText reference", a nerdy phrase from the past.
By default, the "A" element is inline and can be placed within a paragraph or any other text. Links are not limited to just text but we can wrap them around images or even more complex elements like teaser cards. This allows us to create a group of linked elements.
When linking to another website or a specific page on a web, you can include the entire URL. It doesn't matter if it has a trailing slash or not. These types of URLs are called "Absolute URLs" because they point to a precise location on the web. 
In an absolute Url, the HTTP or HTTPS part must be included which stands for "HyperText Transfer Protocol". This protocol defines the rules of communication on the web and is crucial for linking.
When creating links as developers or content creators, we need to include them ourselves. This protocol is one of the significant inventions when the web was created. This is how links are made using absolute URLs.

# HTML URL Pathways
When forming links, absolute URLs are one option. When linking to something within the same site and domain as the page containing the link, a relative URL can be used instead.
Creating a relative URL is not only useful for the "A" element(linking), but it is also a skill used to reference image files, video files, CSS, Javascript files or any other where a files pathis specified.
To form a URL, you need to grasp how files are organized. filenames comes with extensions like ".html", "jpg", "CSS", "js", whereas directories or folder names have no extentions. The Slashes in a Url indicate that we should look deeper into the file structure or go one level down.
Creating well structured and elegent URLs for web page is an art. it is worth considering how your URLs impact user experience and search engine results. Craft URLs carefully.
Using relative URLs can be extremely helpful, especially when working on a project that moves from server to server.
URLs can be either relative or absolute. Relative URLs are based on the current files location, while absolute URLs start from the root of the website. By using folders and index.html files, we can create clean and user-friendly URLs.

# Navigation
Each link is wrapped in an element with the correct URL, and then enclosed in a "<li>" element to create a list of links. To maintain order, wrap the whole list in a "<ul>"element which represents an unordered list. Finally, encompass the entire menu in a "<nav>" element to indicate that it is the site's navigation.
To give the menu a visual appearance, apply CSS styling. Without CSS styling, it appears as a plain list, however, we want screen readers and assistive devices to understand that it is a main menu.
Assign the role "navigation" to the "<nav>" element, which signifies that it represents the main navigation of the page. Include an "aria label" for the main menu, providing a descriptive label that can be read alound by a screen reader.

# HTML Working with Graphics and Images
When we want to add images to a web page, we use the image element, which is simply written as "<img src="image.jpg" alt="brown dog" width="400" height="300">"
there are 4 attributes that need to be included for every image
1. We have the source attribute(SRC), which tell the browser which image file to load.
2. than we have the alt attribute(ALT), which provides a text description for the image.
3. lastly we have the width and height attributes, which determine the size of the image. so every image should have all four of these attributes.
The Image's URL is pasted in the source, and than the image starts loading. Add an ALT attribute, which serves as a replacement for when the image cannot be seen.
Make the ALT text interesting. There is no need to make a lengthy description just focus on what it depicts. You have the option to make the ALT text funny or poetic, and if there is nothing significant to convey about the image, simply leave the ALT text blank.
If the ALT is omitted altogether, there is a chance that the image filename will be read aloud, and we definitely do not want that to happen.
It does not matter whether the height or width is specified first. In HTML, the order of attributes within an element can be whatever you prefer.

# Image formats
The image file itself is a crucial aspect to consider when putting an image on a webpage.It need to be in a file format that web browsers can understand, and there are various options available
We keep coming up with different formats in our pursuit of finding the perfect balance between small file sizes and visually stunning images. we desire a large amount of data to make the image look fantastic, but also minimize the data to ensure faster downloads and prevent excessive data usage for users. Essentialy, we aim for the highest possible quality with the smallest file size achievable. Each file format employes a distinct approach to tackle this challenge, utilizing different techniques to compress the image.
There are four main file formats commonly used on the web these days, each with its own strengths and weaknesses when it comes to compressing images: GIF, SVG, JPG, PNG.

# Responsive Images
CSS offers a solution for displaying images in different sizes to accommodate both large and small screens. The challenge arise when we dealing with big, high-resolution images that contain a large amount of data, resulting in a large file size. This can be problematic for users with limited data plans or slow network as it takes longer to download and can be costly. to fix this issue, consider reducing the size of all your images. This involves making them physically smaller, reducing colored data, and compressing them further, which works well in small screens. However this approach is used universally, users with big screens will end up with low quality and enlarged images.
HTML allows us to deliver different image file to different screen sizes. We can create multiple image files and include them as options to hour HTML code. then the browser and the operating system(OS) takes into account the device's hardware capabilities and network speed to decide on which image to download.
To begin, start with the basic code of loading the image on a webpage. Use an image element with the source attribute that points to the image file, along with ALT text, width, and height. To support different screens, create copies of an image with different resolutions and inform the browser about these options. Then, the device can choose which image to use based on factors like screen density, network connection and user settings. Even if someone has higher-resolution screen, the browser can opt to download a lower-resolution image. 
To demonstrate this, there are four copies of a photo at different widths: 480, 960, 1440, and 1920 pixels. Duplicate the basic HTML code for displaying the image to make changes and compare the results. write code in a usual way, which works well with older browsers and include source attribute pointing to the 1X version of the image, ALT text, Width and Height.
To provide the browser with choices, add the source set attribute. Inside it, list the images on offer, separated by commas. Each entry includes a URL to the file, the resolution (e.g 1X, 2X, 3X, 4X, 1.5X), and so on.The browser will then swap out one version of the image with another based on what it considers best. This technique is ideal for handling different image sizes for retina and high DPI screens 
This is similar to the previous one but instead of specifying the pixel density like 1X, 2X etc, indicate the width of each file: 480w for 480 pixels wide.
The browser now decides which image to show based on device density and viewport width. this could lead to a problem where the chosen image does not fit the layout you want. The browser makes the decision early in the loading process, before it knows the CSS or layout details. It does not know the size of the box where the image will go.
If we know the image will be much smaller than the whole page, we should give the browser more information to make a better choice. Use the sizes attribute in HTML to specify which image to use at different breakpoints. this way, the browser can download the right-sized image for your layout. HTML has powerful options like src set where we can provide a set of images for different resolutions or let the browser choose based on density and viewport width. The sizes allows us to specify how much of the viewport's width the image will take up at each breakpoint. by providing this information in the HTML, we help the browser make intelligent decision, considering network conditions and user preferences.

# Figcaptions and figures
First, show a picture and add a caption to it. Use the figcaption element to wrap the text and designate it as a caption. then put the image and caption together in a figure element. this gives the browser more information about the content, like the relationship between the image and the caption. it is not a regular paragraph or a generic div. this way search engines and AI can understand that these two pieces of content are connected. 
figures can be used for more than just images.e.g use them for interactive graphics. Place it in the same spot as images in the code. The figure and figcaption elements are really useful for anything that serves as a visual illustration or a demonstration of a concept that needs a caption.

# Working with media
 # working with audio
The audio element is different from the image element because it has both the opening tag and closing tag. This makes it more modern and gives it more power and flexibility. just like the image element, we use a source attribute to provide the URL of the audio.
"<audio controls src="audio.mp3"></audio>"
There are different types of audio file formats like MP3, which are not useful on its own and we need to let the browser know that we need it to provide controls like button, timeline and volume control. Using the built-in controls is optional. Instead of using the built-in audio controls, we can create our own controls using JavaScript and HTML media element API. We will add the controls attribute and if the attribute is present that means now there is an audio player on the page. This allows us to play, pause, adjust the volume, see the time and navigate through the timeline. This audio element demonstrate the power of HTML, providing a range of functionality without having to build from stratch.
The are other attributes that can be used with the audio element too. e.g "loop" will make the file repeat from beginning once it reaches the end. "Autoplay" can automatically play the audio as soon as the page is loaded, but be cautious with this one as most people dislike it when audio plays on the web browser without their consent.
The reason the audio element has both the opening tag and closing tag is because the source element can be used to specify multiple audio files, similar to how the picture element is used. 
This can be helpful if a new file format is used that is not supported by all browsers while providing fallback to older ones. to do this, remove the source attribute from the audio element and place it on a separate source element. This accomplishes the same outcome as the previous example but allows for addition of other source elements with alternative audio file formats.
MP3s are widely supported in modern browsers, while OGG had some advantages but did not gain much popularity. There may be a new format on the horizon, similar to AV1 video file format, but not widely available. for this reason, there is no second audio format recommended at the moment. nevertheless, it is important to understand the syntax for supporting multiple file formats, as it was crucial in the past and will likely be useful again in the future.
Create multiple files and list them in separate source elements, and the browser will use the first compitable file in the list. 
furthermore, it is possible to provide fallback text within the audio element, which will be displayed if the browser does not understand the audio element at all. This demonstrates the resilience of HTML, where a single set of code can cater to a wide variety of browsers and provide a suitable user experience. The audio element is an excellent tool for embedding audio files and a player on the webpage.   
 
 # working with video
The web has completely changed how we connect and share things, including movies, TV shows, and even teaching. Thanks to the power of the web, we can now easily put videos on web pages using HTML video element.
Just like the audio element, the video element has an opening and closing tag. to display a video, use the source attribute to specify the video file. and if the controls attribute is added, the browser will automatically create a video player.
The first problem has to do with video encoding. For this example, a video file has been created with 480p resolution, compressed using the H.264 codec, and delivered as an MP4 file. 480p means the video has 480 lines of resolution and is 720 pixels wide by 400 pixels tall. It is not HD or 4K, just standard quality. The H.264 codec was chosen because it is widely supported by browsers.
Just like image formats like PNG, SVG, JPEG or GIF, there are different codecs that can be used to encode video files. Video files contain a lot of data, and if not compressed, the become too large to be efficiently transmitted on the internet. Internet videos, therefore, use a mechanism to compress all the data to smaller packages.
There has been various codecs developed throughout the years, such as Real video, Sorenson, Windows Media, Flash, and H.263. From 2015 to 2020, H.264 was the dominant codec used by most people, however H.264 is not open source, it is a patented codec owned by consortium. They charge licensing fees for every device, Operating Systems, Browser, Camera, or anything that wants to record, compress or play H.264 files. And now, they are planning to charge even more in H.265.
In contrast to freely available image formats such as JPEG or GIF, H.264 is proprietary, prompting the inquiry: should video codecs be subject to distinct treatment? Unlike HTML and CSS, which are unpatented and openly accessible, H.264's proprietary nature raises concerns. To tackle this challenge, significant endeavors have been invested in developing an outstanding, open-source video codec devoid of patents.
Reports indicate that the outcome of the WebM versus AV1 discussion remains uncertain. Recent advancements hint at AV1 potentially surpassing H.264 as a video codec and being free from royalty charges. The HTML video element permits the incorporation of numerous source files, facilitating the concurrent utilization of diverse codecs like H.264, WebM, and eventually AV1. This adaptability also applies to audio and image elements, allowing for the specification of multiple file formats using the source element with suitable attributes. The browser will play the first compatible file it identifies.
Now, let's tackle the second obstacle. Imagine there's a 480p video file suitable for users with smaller screens and slower internet connections. However, for those with faster connections craving high-definition (HD) or 4K content, a larger file is necessary. Regrettably, HTML lacks a built-in method for delivering varying video sizes based on network conditions. This limitation arises from the desire for devices to dynamically adjust their resolution choice, factoring in variables like network speed.
To address this challenge, major streaming platforms such as Netflix, Hulu, HBO, YouTube, and Vimeo employ adaptive bitrate streaming. This sophisticated technique involves a server farm of transcoding robots that ensure seamless transition between different resolutions as users stream videos.
Given the complexity involved, it's common for websites to opt for embed codes from video hosting services rather than directly employing the video element. This decision is often made to streamline the process and capitalize on the capabilities offered by such services.
 
 # Working with Captions and subtitles
It's remarkable how websites can incorporate audio and video elements, yet accessibility remains a challenge as not everyone can hear or understand them consistently. Some individuals may be deaf, while others might experience intermittent hearing issues or difficulty comprehending content due to various factors. Even for those who can hear, listening isn't always feasible.
For instance, you might wish to watch a video but cannot use speakers or headphones in certain settings. Alternatively, you might be listening, but the speaker's accent or fast speech pace poses comprehension challenges. You might even be in such a situation right now, relying on captions for video content. Fortunately, the web empowers content providers to offer information in multiple formats simultaneously.
We will utilize the track element linked to a text file to incorporate captions into the video. This element enhances the video player's capabilities, enabling viewers to toggle captions on/off or switch between different subtitle options. On the web, a file format known as ibvtt (web video text tracks) will be employed. It's a straightforward text file with a vtt extension, adhering to a specific convention for providing information. Each line of text in the file is accompanied by a time code indicating when it should appear in the video.
To display these captions on the video, insert a track element within the video element. Similar to the source element, it's one of the options the browser uses to render the video player. On the track element, use the source attribute to specify the file, the kind attribute to indicate that it contains captions, and a label attribute to display the caption option as "English" in the player. Additionally, use the source lang attribute to specify the language and add a default attribute to make this track the default choice when captions are enabled.
Upon insertion, a captioning icon appears. Clicking on it reveals options for turning captions off, enabling automatic captioning, or selecting English captions. The label "English" appears due to the label setting. To provide a Spanish translation as a different subtitle option, another vtt file for Spanish can be created, and another track element can be added to the same video element. This time, set the kind attribute to "subtitles," the source lang attribute to "es" for Spanish, and the label attribute to "Espa√±ol." As a result, a second choice for subtitles, including Spanish subtitles, appears in the list.
The kind attribute also offers other options. For instance, using "descriptions" enables the creation of a vtt file describing the video's visual elements. Users can select a track that reads these descriptions aloud, making the video more accessible to the visually impaired. Another option is "chapters," which provides a text file listing different sections of the video, allowing users to navigate to specific parts.
In the subsequent section, the utilization of platforms like YouTube or Vimeo, where caption files can be uploaded to provide similar functionality, will be discussed. Captions and subtitles are not only impactful but often legally required. Including them enhances accessibility and inadvertently broadens your audience base. So, incorporate captions and witness your traffic increase!

# Embedding media via IFrames.
Embedding refers to taking content from one site and placing it within the middle of another site's page. 
There exists a broad spectrum of content that can be integrated into a webpage. For instance, this includes a map from Google or Mapbox, a code demonstration from CodePen or Glitch, or even a presentation slide deck from Speaker Deck or Notist. It's a common practice to embed intricate content from a service that manages the technical complexities. Instead of grappling with the development of a mapping service, a slide deck system, a code demonstration platform, or an adaptive bitrate server, one can rely on the toolkit provided by others to handle these tasks. All that's needed is to embed the outcomes onto a website. So, what level of HTML proficiency is required to streamline this process?
You don't necessarily have to grasp every detail because YouTube's engineers have already handled it. However, with your newfound ability to interpret HTML, you can recognize a lot. For instance, the iframe element features attributes such as height and width that are adjustable. The src attribute is utilized to designate the source of the video file.
Although iframes offer versatility, it's essential to factor in security concerns when incorporating code from external websites.
When utilizing a pre-configured content management system (CMS) such as WordPress or Drupal established by someone else, it may not be straightforward to directly copy and paste arbitrary embed codes from external sites. Typically, these CMS platforms have specific methods for allowing URLs or shortcodes only from trusted sources. For embedding items like YouTube videos, it's advisable to seek guidance from someone proficient in effectively utilizing the CMS.
Additionally, when constructing a website, it's crucial to consider security implications associated with the iframe element. If multiple individuals will be contributing content to the system, indiscriminately permitting all iframes without considering security measures is unwise. However, if you are the sole contributor of videos to the website, there isn't much cause for concern.

# HTML Content Identification
The internet spans the globe, encompassing diverse languages spoken by people worldwide. HTML offers mechanisms to specify the language of your content. By configuring these settings accurately, search engines can discern the language of websites. Spell checkers will apply suitable dictionaries, and when a browser reads content aloud, it will pronounce words correctly. It's crucial for computers to identify the language of the content they process.
The lang attribute serves to designate the language of a webpage. If the entire page is in one language, the process is straightforward. Simply set the language on the main element encapsulating everything else, typically the HTML element. This may only need to be done once, such as in a template file that applies universally across the site, but it's crucial not to overlook this step!
For instance, using "en-US" in the lang attribute indicates U.S. English, while "en-GB" denotes English in Great Britain. This distinction is significant for functionalities like spell checkers. Consider whether you prefer "color" spelled with or without a "u". In the U.K., it includes a "u". Therefore, specifying the preferred dictionary and pronunciation is essential. Rather than opting for a generic "lang=en" for English, it's advisable to be more precise.
The lang attribute offers various options beyond indicating language or regional variants; it can also denote other characteristics such as the writing system utilized. If your webpage features multiple languages, specify the language for each segment of content using the lang attribute on relevant elements. For example, if the majority of the page is in Mexican Spanish but includes block quotes in Nahuatl, apply lang="es-mx" on the outer HTML element and lang="nah" on the block quote elements.
Additionally, it's vital to specify the content's direction. While most languages read from left to right horizontally, some follow a right-to-left flow. Utilize the dir attribute to indicate the direction, which can be applied to any element. If all content on your page shares the same directionality, define it once on the outer HTML element.
To wrap things up, do not forget to set the charset for your project. What is that? Well, each language uses its own set of characters or alphabet. In the past, computer character sets were limited and mainly focused on the Latin alphabet. You may have heard of ASCII, which was created in the 1960s and consisted of only 128 characters from English typewriters. Nowadays, Unicode, particularly UTF-8, is widely used. It is like a massive specification that encodes content to support a vast range of characters, scripts, and even emojis. Unicode started with around 7,000 characters in 1991 and has now expanded to over 137,000, aiming to encompass all languages, scripts, and communication forms like Braille and musical notation.
Inform the browser about the character set being used. Otherwise, things can get pretty strange if the computer expects one thing and receives another. 
To specify the charset in HTML, simply include a meta charset tag that equals UTF-8. Place this meta element within the head element on every page of the website, which will be explained further in the chapter eight: HTML Integrations.
Initially, the web made a lot of assumptions about the languages and scripts people would use, and it only supported a few. Over the years, extensive efforts have been made to ensure everyone's inclusion. By defining the lang, dir, and charset for a project, you contribute to a more inclusive future for the web.

# HTML Generic elements, Div and Span
Several HTML elements have been discussed for various purposes, but what about situations when a specific element is needed that doesn't exist? Sometimes, there's a necessity to group elements or highlight a phrase without a predefined semantic meaning. Other times, targeting a specific part of the DOM with CSS or Javascript is required, even if it lacks inherent semantic significance. In such cases, two reliable elements are at our disposal: div and span. If you've worked as a developer writing HTML, chances are you've encountered these elements before.
Before 2010, prior to HTML5's introduction with its helpful semantic elements, divs were heavily relied upon for a multitude of purposes. Divs were utilized for creating sections, sidebars, and various other structural elements. Even today, people tend to excessively use divs and spans in HTML, often without further consideration. This course aims to underscore the importance of semantic HTML.
Technically, one could use divs and spans for everything. Some developers even place titles within divs and make spans simulate buttons. While HTML won't produce an error, and browsers will still attempt to parse the page, it's not considered best practice. This approach can negatively impact user experience. We strongly encourage avoiding excessive use of divs and spans for minor elements and instead opting for the appropriate HTML element that serves the purpose.
However, there are instances when a generic element is necessary. Div is a block-level element, whereas span is an inline element. They essentially have no inherent function until CSS or Javascript is applied to them.
Consider a simple article enclosed within an article element, comprising a headline and four paragraphs. When working on the CSS layout, there's a need to group these paragraphs together to apply a background color exclusively to them, leaving everything else unaffected. To achieve this, introduce a div with a class called "boxes". By targeting this box class with CSS, the desired changes can be achieved.
Now, imagine a specific phrase within the text requires targeted treatment, such as being written in Spanish and needing its language attribute updated accordingly. In this scenario, use the inline element span to delineate the desired phrase. Both div and span can utilize various global attributes like class, id, lang, and aria roles.
Div and span serve as useful fallback options when no other suitable element exists. Remember to use them judiciously.

# Unit 8: HTML Intergration
# HTML Intergration
The comprehensive coverage of HTML, including its elements, attributes, roles, and tools utilized to structure content on websites or web applications, has been addressed. HTML not only plays a pivotal role in defining these elements but also serves as a fundamental component of the web itself.
When accessing a website, users typically open a web browser or web view and input a URL. This can be done by manually typing it into the address bar, clicking on a search result or link, or through an app. Regardless of the method, a URL is involved. In response, the web server sends back the specific HTML file associated with that address.
In the earlier stages of the web, everything necessary to display a webpage was contained within a single HTML file, alongside images. However, with the advancement of technology, the process has become more intricate. Text is often stored in databases, and multiple static files are dynamically combined in real-time, tailored for each user. Visual styling is stored in CSS files, JavaScript in separate JavaScript files, and additional files are used for images, video, audio, and advertisements.
While modern web pages typically consist of a combination of different files, the underlying process remains consistent. Users visit a URL, triggering a request for an HTML file, which the server then returns. The browser interprets the HTML file and executes its instructions accordingly. This initial HTML file serves as the central hub for subsequent actions once the site loads.
Upon receiving the file, the browser immediately begins parsing it and following the instructions sequentially. Additionally, the file may contain references to other necessary files, prompting the browser to request them as well. Once all required files are obtained, the browser proceeds to execute their instructions, resulting in the rapid generation of the webpage.
Now, let's explore the structure of the entire HTML file. While the build system or CMS may not present a single file containing all the code, there are typically templates or theme files that dictate the content.
Within the HTML file, several critical components are necessary for every webpage. Firstly, it should commence with a doctype statement, signifying the HTML file's era. By including this, it signals adherence to modern web standards. Subsequently, the entire content is enclosed within an HTML element, delineating that all content within it is HTML. The HTML element is opened at the top and closed at the bottom.
Furthermore, certain specifics about the webpage, such as the language and content flow direction, are declared at the outset. These specifications ensure clarity for browsers and users alike.
The HTML file is further organized into two primary sections: the head and the body, marked by the head and body elements, respectively. The head contains metadata essential for the browser but not displayed on the page, while the body encompasses the visible content, composed of various elements discussed in this course. The body serves as the primary area for webpage content and interactions.
In summary, the doctype declaration, HTML head, and body elements constitute the foundational elements of every webpage.

# Document Header
Within the head section of a webpage lies crucial information that the browser requires to understand the website. Recall the importance of specifying the character set? This is where it becomes relevant.
The character set is not intended for user visibility but rather for the browser's interpretation. To convey this, the meta element is utilized. It's essential to place meta elements exclusively within the head section as they furnish metadata about the page. For instance, to define the character set, employ the character set attribute and set it to UTF-8. Before exploring other functionalities that meta tags offer, let's begin with an element that's mandatory on every webpage: the title element. It's worth noting that the title element doesn't display visible content.
The webpage title appears on the browser tab or bookmark when saved. It's also the name displayed under top sites upon opening a new browser. Essentially, whenever the browser references this page, it uses the title defined in the title element. Now that the essentials of every HTML page are addressed, let's delve into what else can be managed within the head section.
The meta element serves various purposes. One common application is to notify the browser that the layout has been optimized for small screens, making it a responsive website. Without this meta tag, the browser assumes the page follows an older layout designed for desktops, necessitating scaling down for mobile devices.
Furthermore, it's beneficial to incorporate a site description, visible in search engine results. Ever wondered why specific information about a website appears in a Google search? This is where that data is extracted from. Additionally, the meta tag assigns a name to the webpage when saved to the home screen and specifies a tile image and background color. When a link is shared on platforms like Slack, Asana, or Twitter, it transforms into an appealing card, facilitated by meta tags. Numerous techniques utilize the meta tag to enhance and refine the user experience of a website.
The link element is a vital component extensively used within the head section. It connects various assets to be loaded, such as CSS files, fonts, and favicons. To inform the browser about the asset type, the rel attribute is utilized. Furthermore, the href attribute specifies the URL for the asset. For instance, a link to a stylesheet would appear like this, indicating the rel attribute as "stylesheet." The same format applies to a link to a favicon. Additionally, a link to preload a font file can be included. It's important to consider the order in which the browser loads files, prioritizing items that need to load first at the top.
The script tag is another frequently used element within an HTML document's head. It directs the browser to load a JavaScript file. While it's typically positioned at the end of the document, some also place it within the head section.
In essence, the HTML head serves as a central hub for connecting and configuring various components, ensuring all assets are loaded and sharing page information with other sites and platforms. It acts as the headquarters for ensuring the webpage starts off effectively.

# Content structuring
We just covered what could happen in the document head. Now, let's talk about the typical structure inside the body. There are six important elements to understand:
1. Main: The main element is used once per webpage and tells the browser where the main content is located.
2. Header: The header and footer elements mark the header and footer areas on the page. Do not confuse header with head though. Head is where the file's metadata lives and is not displayed to users. Header is used for site headers, article headers, and headers within the content. A header is usually found at the top of most web pages and may include a logo, site name, and navigation.
3. Footer: The footer signifies that there are extra things to convey, regardless of its position on the page.
4. Article: An article often starts with a title, subtitle, author's name, and publication date, which can also be considered a header. Many web pages end with a footer at the bottom, containing links, copyright information, and additional details about the company. However, footers can also appear elsewhere. Some articles begin with metadata like hashtags or share buttons, which are suitable for a footer element. The article element wraps around any type of content unit, whether it is a long written article, a short snippet, a teaser card, a tweet, or even an app element. It represents a standalone unit of content.
5. Section: The section element is used to mark sections of content. For example, in a long essay with subheadings, each segment can be wrapped in a section element. It is also useful for dividing different topic zones on a website. Each section typically starts with its own headline.
6. Aside: Lastly, the aside element is for content that is off to the side, like sidebar information or additional details that accompany an article but are not part of its main flow. Advertisements can also be marked as an aside. Although the position on the page does not matter, the semantic meaning of these elements is crucial. The visual layout often conveys meaning, and these HTML elements help transfer that meaning from the design to the content.

# When it all comes together
Let's initiate the process of assembling components. This will provide you with an understanding of how we construct web pages from numerous nested elements, each imbued with meaning and interacting with others, contributing to the overall composition.
When uncertain about the optimal markup approach for a page, explore various websites across the web and utilize developer tools to observe how HTML elements are employed in similar contexts. The precise combination of these HTML elements varies for each webpage. It's challenging to ascertain correctness because the appropriate method is contingent on the content and purpose of the page.
In reality, there are typically multiple effective approaches, and none inherently superior. Structuring HTML involves a degree of artistry and offers considerable creative latitude. Ultimately, we endeavor to encapsulate human communication in code, recognizing that while code may strive for precision, human interaction is nuanced and multifaceted.

# Unit 9: Working with forms and Interactive elements
# Form Fundamentals
Form fields have long been integral to the web, serving various purposes such as website logins, purchases, searches, and content submissions.
Utilizing semantic form elements in HTML instead of divs and spans is crucial as it enables us to harness the inherent capabilities of the browser. This approach saves time and effort by avoiding the need to recreate functionalities already provided by the browser. Furthermore, employing HTML form elements ensures compatibility with all devices and input/output hardware, even those unfamiliar to us.
To begin, let's create a basic form for subscribing to an email newsletter. This form requires two fields:
1. Name
2. Email address
To construct the form, commence with the form element, signaling its presence to the browser with opening and closing tags. Within the newsletter signup form, we'll incorporate two fields: name and email. These field names can be converted into labels using the label element.
Utilize the input element to provide areas for users to input their name and email. Unlike other elements, the input element lacks a closing tag due to its older structure. It serves as a marker for the browser to introduce functionality and allocate it accordingly, where the form's operations occur.
Next, we need a button for users to submit the form. Employ the button element for this purpose, with the text customizable to suit requirements. Although visually appealing, the form currently lacks functionality. To enable its operation, a connection to a backend is necessary. While a demo can be made functional by adding action and method attributes, using the "get" method is insecure and not advisable for real websites.
Upon submission, the response page may not display the entered data. This occurs because the input fields require a "name" attribute to transmit data. Assign "name=name" to the first input element and "name=email" to the second. The name attribute can be customized as needed. Following these adjustments, the form functions successfully, albeit only when interacted with using a screen and mouse.
To ensure accessibility for all users, it's essential to address the disconnect between the label and input elements. There are two options to achieve this:
1. Add a "for" attribute to the label that matches the "id" attribute of the input.
2. Wrap the input within the label.
Both approaches are effective, and the choice depends on the desired markup structure. Test the connection by clicking on the label and verifying that the focus shifts to the corresponding input. This is crucial for accessibility, as many individuals rely on this linkage. Clicking on the label provides a quick way to confirm its functionality.
These steps outline the fundamentals of building an HTML form. In the next phase, we'll explore leveraging additional browser features to enhance the user experience.

# More Form Functions
The objective is to construct a form for gathering a name and email address, facilitating sign-ups for an email newsletter. Presently, both input elements collect text indiscriminately. Users could input any text, even though one field is designated for an email address. This is because we haven't informed the browser about the type of input expected from these fields.
Resolve this issue by adding the type attribute to each input. For the name field, we'll collect text, which is the default behavior. If the type attribute is omitted, the browser automatically assumes it's text. For clarity, explicitly specify type="text". For the email field, instruct the browser to collect an email address and guide users in filling out the form correctly by setting type="email". Now, when users complete the form, the browser validates that the entered data is an email address. If users attempt to input anything other than an email address, they receive a warning prompting them to rectify it.
Additionally, designate our button as a submit button to inform the browser which button to activate when users hit "return" on their keyboard. We can also add a required attribute to make the email field mandatory. Consequently, the browser insists on the email field's completion before submitting the form. If an email is not provided, the browser won't submit the form upon selecting the submit button, instead prompting users to fill out the required fields.
Lastly, include a placeholder or default value. Often, designers prefer pre-populating form fields with suggestions to guide users. HTML accommodates this by employing the placeholder attribute, allowing the inclusion of a suggestion or example in the intended field. This suggested text appears in light gray by default and vanishes upon clicking the field, ensuring users don't have to erase it to input their own email address. The placeholder purely serves as guidance and should disappear when no longer needed.
Furthermore, the value attribute pre-populates the field with actual content. However, this can pose a problem if users need to manually erase the suggested text to input their email address. The value attribute is useful for pre-populating forms with anticipated answers, commonly utilized in auto-completed forms. When both attributes are included, upon form submission, the placeholder text isn't submitted as real data, while the information pre-populated by value is.
Forms can be complex, but by harnessing the power of HTML, you can ensure your form functions seamlessly for all users. In the next section, we'll explore various types of forms beyond text and email.

# Other Form element types
Now that we've grasped the fundamental structure of a form, let's explore the diverse array of options available for collecting various types of data. Forms need not be aesthetically unappealing; CSS can be utilized to style them, elevating their appearance beyond simple text boxes. Employing proper semantic HTML elements within forms enables customization, allowing for a unique look and feel.
Consider the same name and email form elements with improved styling, along with additional fields for password, search, and phone number. These new fields closely resemble the structure of text and email form fields. The password field, indicated by type="password", triggers a browser warning due to the absence of HTTPS, emphasizing the importance of secure connections, particularly for sensitive information like passwords. Some browsers may prompt users to utilize an integrated password manager for faster input.
The search field and phone number field exhibit distinctive features as well. The search field may display differently across browsers and trigger a specialized keyboard, while the phone number field often prompts a telephone pad interface for easier input.
But what about capturing longer passages of text? For this purpose, the text area element should be employed, similar to the input element but designed for multiline input. The cols and rows attributes can be utilized to specify the size of the text area, although CSS often overrides these values.
Expanding our form, let's introduce additional input types: date, color, and file. The date input type facilitates easy date selection, while the color field invokes a browser-based color picker. The file field allows file uploads, with added attributes like "accept=image" and "multiple" to specify acceptable file types and allow multiple uploads, respectively.
Furthermore, checkboxes, select lists, and radio buttons provide versatile options for user interaction. Checkboxes can be implemented using labels and inputs, with the "checked" attribute indicating a pre-selected state. Select lists, created with the select and option elements, offer dropdown functionality, while fieldsets and legends can be utilized to group checkboxes or radio buttons for better organization.
This brief overview showcases some of the many HTML form elements available, harnessing the capabilities of browser software and operating systems across various devices.

# Unit 10: Organizing tabular information in HTML
# HTML Tables
You may have encountered the notion that HTML tables are to be avoided, but this is not entirely accurate. HTML tables are perfectly acceptable when used appropriately for tabular data. The key is to refrain from misusing table elements to create layouts that are not actually tables.
Semantic HTML aims to accurately convey the nature of content to computers. If you have a button, use the button element; if you have tabular data, use the table elements. So why the negative perception surrounding HTML tables? Back in the early days of the web, before the advent of CSS and proper layout tools, people resorted to various methods to style and structure their content. This often involved slicing content into pieces and placing them within HTML table cells to achieve a desired layout. While this workaround may have appeared visually satisfactory, it resulted in poor semantic structure, making the content inaccessible, unreusable, and difficult to find.
Despite advancements in web design, this outdated technique persists in HTML email due to limited alternatives. However, in modern web development, HTML tables should be reserved exclusively for presenting tabular data.
Tabular data, such as research findings or comparative information best organized into rows and columns, are ideal candidates for HTML tables. Think of how you decide to use tables in applications like Google Docs or Microsoft Office‚Äîwhen presenting information that benefits from clear alignment and comparison, a table is the appropriate choice.
Tables are effective for displaying various types of data, whether numerical, textual, or visual. As long as organizing the data into rows and columns enhances its semantic meaning and facilitates relationships between cells and headers, using an HTML table is justified.
Furthermore, CSS can be employed to modify the appearance of tables, allowing for flexibility in presentation across different screen sizes. The crucial aspect is to recognize when the inherent nature of the information warrants a tabular format and to use HTML tables accordingly.
# building HTML Tables
To construct an HTML table, you employ a combination of HTML elements: Table, TR, TH, and TD.
Here's an illustration of an HTML table. The table element encapsulates the entire table, enclosing all content and markup related to it, denoting the table's beginning and end. The TR element represents a table row, enclosing a group of elements that belong to the same row. TH represents a table header, defining a header for a column, while TD marks up the cells of data.
Let's walk through this with a straightforward example. We commence with a table element to signify the table's start and close it at the end. This table comprises six rows: five rows detailing various birds and a top row containing column headers. We utilize the TR element to markup each row, employing six pairs of TR opening and closing tags for the six rows, and then insert content inside each row, beginning with the American goldfinch.
We use the TD element to enclose a cell of content, such as the American goldfinch's name, color, diet, and an image with an image element. Any HTML markup, such as paragraphs, videos, or headlines, can be placed inside these cells. Since there are four columns in this table, each row contains four data cells. The remaining bird information is filled in similarly.
To enhance the table's appearance, we apply some styling and CSS to customize its look instead of relying on the browser's default styling. As for the header, we place the header content in the first row, wrapping each item in a TH element instead of a TD element. While TD denotes table data, TH signifies table header. The header elements like "Bird," "Color," "Diet," and "Photo" are not in all caps in the HTML document, as they are not acronyms. Instead, they are entered as normal words in HTML, and CSS can be used to alter their appearance. This ensures proper pronunciation when spoken aloud and facilitates easy styling adjustments using CSS.
These are the fundamental aspects of table markup. There are more advanced techniques to create complex HTML tables, such as spanning content across multiple rows or columns, defining headers, bodies, and footers, or adding a caption. Numerous courses delve deeper into HTML tables, including guidance on creating HTML email templates. However, this course focuses on the basics: the table element, TR for table rows, TH for header content, and TD for cell content.


# Introduction to Cascading Style Sheets (CSS)
# Unit 1: Introduction to CSS
What is CSS?
A style sheet, like a CSS file, contains all the styles for your webpage, enhancing its visual appeal. To link HTML and CSS, you simply connect them. HTML and CSS are closely intertwined and complement each other, but before we explore CSS further, let's briefly review HTML.
HTML focuses on recognizing commonly used elements such as paragraphs, headings, lists, and links, which define a webpage's structure. When you view raw HTML in a web browser, it appears unattractive, with default styles like Times New Roman font, bold headings, and blue underlined links, dictated by a style sheet within the browser. While we can create readable and understandable webpages using only HTML, they lack visual appeal. CSS comes into play to enhance the appearance by altering the font, colors, and spacing.
CSS comprises two components:
1. The selector.
2. The declaration block.
The selector identifies a pattern in the HTML, and if the pattern matches, the styles within the declaration block are applied to the corresponding HTML elements. Multiple styles can be applied to the same pattern, which is where CSS's cascading feature comes into play. However, we'll keep things straightforward in this course and won't delve deep into cascading.
# CSS Components
In CSS, each style declaration comprises two components:
1. A property.
2. A value.
Throughout this course, we'll focus on a specific set of properties and values. However, it's important to note that there's much more to explore if you're interested in furthering your learning and expanding your skills.
The initial aspect of CSS is the selector because it's crucial to be able to target specific elements in our HTML. Without this capability, understanding properties and values won't be very practical. Therefore, we'll begin this course by creating some visually unappealing web pages.

# Adding CSS Selectors
# Writing comments and Element selector
To initiate your journey with CSS, we'll start by crafting basic CSS code for your document. Within the Exercise Files, locate the link to the initial Sublime Text file for this segment labeled "01-01-start: Writing Your First Element Selector‚Äù. Upon opening it, you'll discover a collection of headings, subheadings, and paragraphs that serve as our canvas for experimentation.
Before delving into CSS, it's beneficial to review the HTML structure you aim to style. Identify any recurring patterns that can be leveraged in your CSS code.
In the provided exercise file illustration, we encounter an H1 representing the title of our site, "H+ Sport," followed by a paragraph, an H2 detailing company history, and another H2 covering guarantees and ideals, encompassing sections on guarantee and philanthropy. Interspersed are several paragraphs along with annotations, such as an HTML comment at the outset, elucidating the distinction between HTML and CSS comments. CSS comments are delineated by a slash star and a star slash, providing a means for personal annotations for reference during code composition.
Now, let's delve into CSS selectors. The initial type is the element selector. If our intention is to designate all paragraphs on our page to appear in blue, we utilize the HTML element P as the selector. Consequently, in our CSS, we denote "P" devoid of angle brackets and define the color property as blue. It's a straightforward process. Complexity can be introduced subsequently, but for now, let's maintain simplicity.
Should we aspire to render all H2 elements in red, for instance, we deploy the selector "H2" within the CSS. Once again, we employ the color property and assign it the value of red. Consequently, all H2 elements on our page will exhibit the red hue.
We encourage you to experiment. Craft styles for H1 and H3 elements, selecting colors of your preference for each heading text. Refer to the 01-01-End state of the Sublime Text in the Exercise Files to observe the implementation. Congratulations! You've embarked on your journey of CSS composition.

# writing a class selector
In your current project, all paragraphs are uniformly styled in blue. However, what if we need to make a particular paragraph green? Or perhaps, we wish to highlight a specific portion of a paragraph in green. How can we achieve this?
To create such targeted styling, we can assign classes to HTML elements, providing a reference point for customization. A class serves as an attribute that can be appended to any HTML element, offering additional descriptive information about that element.
Let's start with the HTML code. Suppose we want the initial paragraph to appear in green; we can introduce a class attribute to the paragraph tag, naming it something like "intro" to denote its introductory nature. In CSS, we differentiate class selectors from HTML element selectors by prefixing them with a dot (.). Therefore, we would write ".intro" in CSS and specify the color as green.
Now, if we aim to style a specific segment within a paragraph differently, we can utilize a span element with a class attribute. For instance, let's make the sentence concerning the guarantee stand out by rendering it orange and bold. This can be achieved by encapsulating that sentence in HTML with a span tag bearing the class attribute "guarantee". Subsequently, in CSS, we target ".guarantee" to select that class and define the color as orange while setting the font-weight to bold.
It's important to note that the order of style declarations in CSS is flexible. For instance, if we apply the "guarantee" class to a paragraph element, the entire paragraph will adopt the orange and bold styling. HTML assists us in pinpointing specific segments within a sentence.
Now it's your turn to put this into practice. Take the sentence "Philanthropy is extremely important to us" and modify it to appear in black, bold, and all uppercase. A starting point has already been provided by setting the class name as "important" and the CSS property "text-transform: uppercase". Find a way to target that sentence within the HTML and complete the styling by making it black and bold.

# Grouping selectors
There are occasions where you desire to apply a consistent style across various types of selectors. For instance, if we wish for all paragraphs on this page to appear in green, you should now be familiar with how to achieve this. Go ahead and implement that style now.
If you've followed along, well done! Now, consider extending this to make the list items green as well. How would you go about styling them in CSS? Take a moment to inspect the HTML and contemplate your approach.
Chances are, you might write something like this: . If that was your line of thinking, you're correct! However, what if there were numerous other elements and classes also requiring the green styling? Adopting this approach would entail a considerable amount of repetitive code. This is where grouping selectors proves advantageous. Instead of crafting separate styles for <p> and <li>, we can merge them using a comma: . The browser will then apply this style to all paragraphs and list items, assessing each one individually. 
But what about incorporating a class? That's entirely feasible too. Suppose we also want to render the words "mineral water" in green. We can include .mineral to the selector, where ".mineral" is the name of our class. Subsequently, within the HTML, we can apply the class to the specific text using <span class="mineral">. This action will similarly render the word "mineral water" in green. So, whenever you encounter selectors grouped together with commas, each of those items signifies a separate selector. Whether it pertains to paragraphs, list items, or anything tagged with the class "mineral," the text will be styled in green.

# Descendant selectors
Let's take a closer look at the HTML in our code pen. Besides headings and paragraphs, there are two lists presented under the "ingredients" section.
The initial list follows a specific sequence, commencing with mineral water as the primary ingredient and concluding with the least amount of natural raspberry flavor. It is an ordered list. Conversely, the variations of mineral water may possess different flavors with no defined sequence, rendering it an unordered list. Utilize distinct types of lists to delineate this disparity.
Regarding styling, gather paragraphs, list items, and elements labeled with the class "mineral" together and apply a green color to them. Next, customize the ordered list items to appear in blue and bold, while the unordered list items should display in purple and uppercase. One method to accomplish this is by individually assigning a class to each list item, yet this would entail considerable typing and effort. Fortunately, there exists a simpler technique known as a descendant selector.
HTML hierarchy resembles a family tree, where elements have parents, children, and descendants. In our scenario, the body tag serves as the parent, while the HTML elements within it act as the descendants. The ordered list is a child of the body, and its list items are its children.
A descendant selector empowers us to choose list items that are descendants of either an ordered or an unordered list. This connection can be direct or indirect, akin to a family tree. To implement styles using a descendant selector, we can employ the code "OL LI" (without the body tag). The space between "OL" and "LI" indicates the descendant relationship. Subsequently, we can specify the color as blue and the font weight as bold. Only the list items associated with the ordered list will undergo modification.
When dealing with CSS selectors comprising multiple terms, it's vital to remember that they are interpreted from right to left, despite being written from left to right. In this instance, we are essentially stating "any list item descending from an ordered list".
Now it's your turn to experiment. Craft a style that selects the list items within the unordered list and render them in purple and uppercase. Once completed, review the final state of the code pen in the exercise files to verify the accuracy of your solution.


# Unit 3: CSS Images and Colors
# Identify Color scheme
Color selection might appear straightforward, but it's a subject worthy of its own dedicated course. The objective is to establish a color scheme or select specific colors for your website. So, where do we acquire a color palette from?
If you possess a background in design, you can craft one yourself. However, if you find yourself struggling with color choices, fret not! There are numerous resources available. We'll elucidate Canva's methodology, but if you search for a color palette generator on Google, you'll discover myriad alternatives.
Canva serves as a user-friendly graphic design ally for non-designers. They proffer three distinct approaches to crafting color palettes. The initial method is showcased prominently atop their webpage, with the link provided in your exercise files folder. Take a gander at the exquisite color palette inspired by a snapshot of donuts. Canva has extracted several colors from the donut image, suitable for a webpage devoted to donuts. Another avenue for creating a color palette involves experimenting with their demo image.
Subsequently, consider a photograph featuring individuals in a canoe. Observe that colors have been directly extracted from the image, such as dark green, pinkish hues, and lighter grays. Upon further clicks, you'll encounter a plethora of options for demo images. Thus, if you chance upon an image that captivates you and wish to integrate its color scheme, simply upload it to Canva, and you might uncover a palette perfectly suited to your website.
Continue perusing this page; numerous color palettes are available, and the examples provided are merely a fraction of what's on offer. Let's assume you're intrigued by one titled "Rosettes and Cream." Clicking on it will transport you to a page showcasing the picture that inspired this color scheme. It delineates the colors comprising the palette and also suggests related combinations. Should you fancy this scheme but desire a touch of purple, feel free to utilize these palettes to fashion designs.
Should you click the back button, another option at the page's bottom is to fashion a custom color palette. Following that link redirects users to a page where they can designate their initial color, prompting the system to generate a corresponding color combination. For instance, opting for an aqua blue hue yields a complementary color combination, the opposite shade on the color wheel.
Users can also explore other combinations such as monochromatic (involving two analogous colors), analogous (featuring a spectrum of greens and blues), or triadic (creating a pattern on the color wheel using an equilateral triangle). Additionally, there's the option of tetradic, which produces a square array of colors.
These combinations are invaluable for identifying matching colors. Users have the flexibility to adjust the color palette's saturation or experiment with different variations. However, if utilizing the color wheel directly seems daunting, users can peruse the available color palettes, categorized and filterable by keywords like "birthday." These keywords aid in narrowing down options based on associative themes. Alternatively, users can explore the extensive palette collection or even upload an image to generate a custom color palette.

# Formatting color on CSS
Once you've settled on a color palette, the subsequent step involves integrating it into your code. While this might appear straightforward, as it has been covered in this course, we've primarily employed what are known as named colors thus far. These are colors with specific names assigned to them. Nonetheless, despite the vast array of colors available online, only a limited number of them are endowed with names in CSS.
The provided color chart exhibits examples of these named colors, which you can readily utilize in your code. However, it's crucial to acknowledge that your color palette might not incorporate any named colors, as there are only approximately 130 of them accessible. So, what recourse do you have if the color you desire lacks a name?
The prevailing method for representing colors online is through hex codes, also referred to as hex values or hex format. "Hex" is an abbreviation for "hexadecimal." Hex values typically consist of six digits, comprising numbers from zero to nine and letters from A to F. The initial two digits denote red, the subsequent two represent green, and the final two signify blue. These digits correspond to numbers spanning from zero to 255.
Interestingly, the chart of named colors also offers the hex value equivalent. For instance, utilizing the name "Cornflower Blue" or the hex value "6495ED" yields the same shade of blue.
Canva's color palettes likewise exhibit hex values. Both color names and hex values constitute the most commonly employed methods for working with colors on the web.
While perusing other individuals' CSS, you may encounter alternative syntaxes worth mentioning. For instance, the hex value "7778899" can be abbreviated to "789" if each two-digit pair is identical. This three-digit format is relatively prevalent but applicable only when the numbers are uniform.
Another syntax you might come across is the RGB format, where colors are delineated using Base 10 numbers to specify the red, green, and blue channels. This format can also be expressed as an eight-digit hex number or RGBA. In both scenarios, the last number (e.g., "CC" in the hex value or "0.8" in the RGB value) pertains to Alpha, which denotes the opacity and transparency of the color. It dictates the extent to which the color allows visibility through it. Other color formats such as HSL or HSLA may occasionally be employed, particularly within platforms like Squarespace.
Converting between color formats is straightforward! Simply input your color value into Google, and it will furnish you with a color picker offering various conversions.
Alternatively, if you prefer DuckDuckGo, it also provides color conversions, alongside complementary and analogous colors for your website. Another avenue is to visit the Color Hex website, where you can explore shades, tints, and color palettes corresponding to your chosen color. Depending on the specific information you require, any of these resources can prove invaluable.

# Background and text color in CSS
In the H1 section, there's a delightful pink hue, but it presents readability challenges against a white background. To identify a color that suits our preferences, consult the named color chart provided in the exercise files, navigate to the teal color, and select one. Substituting the pink with teal demonstrates its suitability on our webpage.
Alternatively, you can opt for a color palette. Canva offers one named "Fiery Cracked Earth," containing colors that might appeal to you. It's important to note that Canva assigns names to these colors, but they might not translate directly to Sublime Text. Instead, rely on the hex values provided on the CSS named Colors Chart. For example, if you wish to employ the teal alternative for an H2, copy the hex code from Canva and replace the existing color in the CSS.
It's noteworthy that the shades of teal in Canva and the CSS chart may differ.
We can also modify the background color for elements. By utilizing the "background-color" property and specifying a hex color, you can alter the background behind specific elements. For enhanced readability, adjust the text color accordingly. For instance, set the text color to white using the hex code "FFF" or "FFFFFF" against a white background.
Moving on to the unordered list (ul), instead of applying a text color, designate it as a background color. Opt for the beige hue from Canva and assign it as the background color for the ul. Lastly, remember that you can also style the entire webpage by targeting the "body" HTML element. By selecting a specific color, such as the yellow shade from Canva, you can alter the background color for the entire page, providing a distinct appearance from the default white.
In summary, we've explored the concept of utilizing colors in text and background elements. You have the flexibility to choose a color for the text and another for the background, whether it pertains to a specific element or the entire page. Additionally, we've demonstrated how you can select colors from the named color palette or craft your own custom colors using Canva.

# Understanding Images in CSS
Images are commonly encountered on webpages and can be incorporated either through HTML or CSS. Initially, we'll delve into image formats suitable for the web, followed by an exploration of how to integrate images using HTML and CSS.
Numerous image formats exist, including GIF, PNG, JPEG, bitmap, TIFF, and various proprietary formats like PSD. Traditionally, the web has accommodated three primary image formats:
- GIF: Known for its limited color range but ability to include transparency and animation.
- PNG: Offers more colors and transparency but lacks animation. GIF and PNG are typically employed for illustrations such as logos or cartoons.
- JPEG: Abbreviated for Joint Photographic Experts Group, optimized for photographs, supporting millions of colors but devoid of transparency and animation.
Recently, a new image format named WebP has emerged. WebP is versatile and offers high compression for smaller file sizes, leading to expedited website loading times. Its versatility and efficiency in swiftly loading both photos and illustrations with minimal file sizes are anticipated to drive its growing popularity.
When handling images, selecting the appropriate format is crucial. Saving a photograph as a GIF may result in color degradation and potentially larger file sizes. Additionally, optimizing images for faster downloads involves resizing them to the required dimensions, trimming unnecessary parts, and reducing file sizes. Images directly captured from mobile phones or cameras are typically large and require longer download times. After setting dimensions, reducing file size optimizes image loading speed. Tools such as tinypng.com or Adobe Photoshop facilitate image file size reduction, ensuring enhanced website loading speed and improved user experience.
Now that we grasp the fundamentals of images, let's explore their inclusion in webpages using HTML and CSS. In HTML, the image element is utilized to embed images alongside text, crucial for conveying the page's message, such as logos or social media icons. Conversely, CSS enables the incorporation of background images, primarily ornamental and non-essential to the webpage's text. Background images can be configured to repeat or display only a portion of the image. Let's delve into these properties further through code.

# Working with background Images in CSS
Now, let's incorporate background images into our webpage. Begin by inspecting the images we'll be utilizing. Within the CSS, you'll find two background images specified as comments. Take note of the "background image" property and the enclosed URL value within parentheses. Copy the URL and paste it into a new browser tab to preview the image. The "blue dots" image features multiple blue dots, while the "LIL CSS, no code growth" image displays a distinct design. It's imperative to preview these images before implementation.
Next, apply the "blue dots" image to the webpage. Remove the comment and designate it as the background image for the body element in HTML. Note that the image size may be smaller than its appearance on the page, but it adjusts seamlessly. Background images possess flexibility and can tile both horizontally (X-axis) and vertically (Y-axis), creating a wallpaper-like effect. This is particularly effective for low-contrast images like the "blue dots". Alternatively, you can assign the background image to specific elements, such as an H1 heading, where it will exclusively fill that space.
Currently, the text may appear cramped against the edges, and the overall appearance may be unrefined, but we'll refine it later in the course.
Now, let's consider the second image featuring growing plants. Similarly, set it as the background image for the body element. Observe that the image tiles across the page both horizontally and vertically, resulting in decreased readability and visual appeal. However, enhancements can be made. Instead of utilizing the "background-image" property, employ the shorthand property "background" for greater flexibility. By incorporating "repeat-X," the image will only repeat horizontally. Likewise, "repeat-Y" can be used for vertical repetition. To dictate where the background image commences, specify values such as "center," "right," or "left." Additionally, "bottom" can be used to position the image at the bottom of the page.
Regrettably, the background image may only appear at the bottom of the content because the body height of the webpage is contingent upon its content. To circumvent this limitation, add a height value, such as "97vh" (97% of the viewport height), to position the image as desired. In this scenario, we desire it at the bottom of the page, evoking the impression of soil at the base. You can apply the same background image to other elements on the page, such as an unordered list (UL), without specifying a height.
By experimenting with diverse background images and properties, you can elevate the visual allure of our webpage.
The background image set for the UL appears somewhat awkward in this instance. Enhance it by adjusting the bottom to approximately 50%. This will diminish the vacant space and display more of the plant in this particular scenario.
Percentages can be employed to fine-tune where these images appear on the page. The efficacy of this approach varies based on the background image utilized but can yield aesthetically pleasing results.
These recommendations should spark creative ideas for utilizing background images in webpages. There are additional styling options available for these images, but the provided values here should inspire innovative approaches to integrating them into your next website design.

# Unit 4: CSS types, boxes and sizes
# Understanding type in CSS
Most individuals find unattractive and poorly constructed web pages unsettling, acknowledging a clear issue with their visual appeal. The primary concerns typically revolve around font choices and spacing. Let's delve into these aspects.
In this chapter, we'll address fonts first, leaving spacing for later discussion. Assuming you already possess some familiarity with fonts, we'll expand upon that knowledge. Generally, those without design expertise tend to classify fonts into two categories:
1. Serif.
2. Sans serif.
Serif fonts feature small lines, or serifs, at the ends of letters. Historically, they were employed in printed materials containing extensive text blocks. The imprecise alignment of manually set printing press letters was aided by serifs, enhancing readability.
Conversely, sans serif fonts lack serifs, boasting a more contemporary appearance. In digital typesetting, they're predominantly favored for web-based extended text due to their clean and legible nature.
Now, what's the default web font? Typically, it's Times New Roman, though exceptions exist. Web fonts differ from print fonts, as they rely on their source. Given the diverse devices people use to access web content, font availability varies. To ensure compatibility, CSS often specifies multiple fonts simultaneously‚Äîa practice known as a font stack.
For example, a common font stack might include Arial, Helvetica, sans serif. Arial is prevalent on PCs, Helvetica on Macs, with sans serif serving as a fallback for devices lacking the former options. Other commonly safe fonts include Verdana, Times, Times New Roman, Georgia, Trebuchet MS, and Comic Sans, though the latter is often advised against.
If you seek alternatives beyond these fonts, Google offers a vast array of over a thousand fonts suitable for website integration. These fonts are fetched from the internet, guaranteeing display even if the user lacks them locally. However, for the purposes of this course, we'll adhere to basic fonts typically available on users' devices. In practical scenarios, your development team would guide you on selecting an appropriate font stack for your CSS. With the underlying concepts clarified, let's move on to some coding exercises.

# Applying type formatting with CSS
After covering fonts, let's transition into coding. In the previous challenge solution from chapter two, the presentation was acceptable but not exceptional. Now, we'll implement some adjustments to enhance the visual appeal by employing different fonts. Firstly, introduce a font-family property to the body element. This property facilitates font alterations throughout the page. Employ a font stack, commencing with Arial, followed by Helvetica, and ultimately Sans-serif. The web browser will sequence through these fonts; if Arial is accessible, it will be displayed, otherwise, it will attempt Helvetica. If neither is accessible, the computer's default Sans-serif font will be utilized.
Ensure that both Arial and Helvetica are installed on your computer. By examining the plus sign on the page, we can readily discern the distinctions between these two fonts. The plus sign subtly shifts when Arial is removed from the font stack, leaving only Helvetica. This illustrates the variance between the two fonts. If Helvetica is also omitted, and only the font-family Sans-serif is applied, the default Sans-serif font for the Chrome browser on your computer will be employed. Judging from the plus sign's position, it's likely that Helvetica serves as the default Sans-serif font. Nevertheless, appearances may differ across various devices.
It's imperative to acknowledge that attaining flawless font consistency across all devices is unattainable. The objective is to achieve a satisfactory and legible appearance; absolute uniformity on every device is not obligatory. In this instance, designate Arial, Helvetica, Sans-serif as the font for the entire page. Nonetheless, it's advisable not to overuse different fonts, as this can undermine professionalism. For headers, opting for a distinct font creates contrast. For instance, employing a serif font like Georgia and Times New Roman for h1.
Remember to encapsulate font names comprising multiple words within quotes, with the comma positioned outside the quotes.
By incorporating a contrasting serif font for headers and a Sans-serif font for paragraphs, readability is enhanced, particularly for lengthier text displayed on screens. Additionally, further experimentation with various properties is plausible. For instance, italicizing the text can be achieved by adding font-style: italic. Furthermore, if the bold style is deemed excessive for our headers, setting the font weight to normal achieves a more refined appearance. These adjustments confer a distinctive aesthetic to our headers.
Simply by eliminating the Times text from the page and adopting a Sans-serif font, a significant enhancement in the overall appearance is evident. The text becomes markedly more legible.

# Understanding and applying sizes in CSS
So far, the text size on our web page has been dictated by the default style sheet of the web browser. There's nothing inherently problematic about these sizes, but at times, you might feel the necessity to tweak them or apply them selectively to certain text sections.
In the realm of web design, there are two primary types of sizing: absolute and relative. Absolute sizes, such as points or pixels, remain constant regardless of screen dimensions. Conversely, relative units like percentages or R-E-M (pronounced "rem") can adapt based on page size. When zooming in, font sizes using relative units scale proportionally with the rest of the page, hence why web designers often opt for relative units for enhanced flexibility.
Among web developers, the preferred font size unit typically leans towards "rem." Essentially, 1 rem equates to 16 pixels. For instance, if a font size is specified as 1.5 rem, multiplying it by 16 yields approximately 24 pixels. Conversely, a font size set as 0.8 rem is roughly equivalent to 13 pixels. Fortunately, manual calculations aren't necessary as there are numerous online calculators available for this purpose. Let's explore one of these calculators.
An example is the Point to REM Converter tool found on codebeautify.org, accessible via the provided link in your exercise files. While working with web design, some individuals find it more intuitive to think in pixels rather than rem, particularly if they receive sizes in points from their designer, a common practice in print design. This calculator facilitates conversions between various size units utilized on the web.
For instance, suppose you wish to work with a font size of 18 pixels. Inputting this value into the font size calculator would yield 1.125 rem, the recommended format. The calculator also offers conversions for em and percent, alternative size units. Em is less prevalent nowadays, while percent is advantageous for layouts. Nonetheless, rem remains the favored unit for font sizes.
Similarly, if a graphic designer instructs you to use 18 points, the converter would provide the equivalent in rem, such as 1.5 rem in this scenario. It's essential to note that rem values can include decimals. Armed with the knowledge of size conversions, you can effectively apply this in your code to ensure consistency between your vision and the appearance on your web page.
Now, let's proceed with adjusting the font sizes on our web page. Beginning with the h1 heading, if we desire a specific size, we can utilize the "font-size" property and input the desired value, such as 2rem. Initially, you might not notice any change, as we may have guessed the current size accurately. To confirm, experimenting with different values, like 3rem, will demonstrate noticeable changes. The key is to experiment because in web design, nothing is rigidly fixed.
Furthermore, we can tweak the font size for the body of the page, albeit with a slight variation in operation. When applying a size to the body, it scales proportionately to all other fonts on the page. For instance, setting it to 1.2rem would enlarge everything except the h1 heading, as we've explicitly defined a distinct size for h1, unaffected by the body's size. This concept ties into the notions of cascading and inheritance in CSS, which we'll briefly address later in the course. While this might cause some confusion initially, rest assured, we'll clarify it.
Moreover, we're not confined to the current font sizes. If we desire the "go outside and play" text to be significantly larger, we can introduce a specific style for h3 and set its font size to 4rem. Contrary to common belief, there's no strict rule mandating that lower-level headings (h2, h3, h4, etc.) must be smaller than h1. Depending on the context, you might prefer h1 to be small and h3 to be large. It's important to recognize that default heading sizes are determined by the browser's style sheet. However, with CSS, you retain the flexibility to tailor heading sizes to your preferences. Rather than altering your HTML to adjust font size, employing CSS is the recommended approach for such modifications.

# Understanding the Box model in CSS
The web page we've developed looks satisfactory with the basic CSS adjustments we've applied. However, a significant issue we've identified is the inadequate spacing. It's noticeable that there's insufficient room between the text and the color bars.
For instance, examining the words "play" and "go outside and play," you'll observe that the bottom of the letters P and Y are touching the edge of the color box. Although in Sublime Text, there's some whitespace between the color bars and the web page's edge, there's a noticeable gap between "H plus sport" and "what is the best exercise?" It would be advantageous to eliminate that gap. Therefore, to tackle these issues effectively, we must delve into understanding spacing properties, which necessitates discussing the box model in CSS.
In web development, each HTML element is akin to a box with distinct properties. These properties persist even if their value is zero and not visibly apparent. Let's deconstruct how these properties function. First and foremost, there's the content, which comprises the text inside the box. Subsequently, there's the border, akin to a line encompassing the content. We have the option to display all four sides of the border or just a select few, with various available styles.
Following the border, we encounter padding, which denotes the space between the border and the content. It can also possess its own background color. When we incorporate padding, essentially, we're pushing the box's edge away from the content.
Beyond the border lies the margin, which denotes the space between elements on the page. If there's a need to separate intersecting elements, introducing some margin will suffice.
We have the capability to assign properties to individual sides or apply them universally to all four sides. Shorthand values are available for border, padding, and margin, offering a more concise approach to setting these properties. While only a few examples are provided here, there's much more to explore on this subject.
Commencing from the top of the slide, by employing the CSS property "border: 1px solid red," we can introduce a one-pixel-thick red border, creating a solid red border around the element. Subsequently, utilizing "border-left" will exclusively apply the red border to the left side of the box, leaving other sides unaffected.
Similarly, regarding margin setting, utilizing "margin: 1rem" will add one REM (root em) of margin to all four sides of the box. However, specifying "margin-right" will exclusively add the margin to the right side of the box.
Padding also offers flexibility. We can employ fractional REMs to establish padding on all four sides or solely on a single side. There exist other shorthand notations for padding and margin, alongside longhand properties for borders. However, to prevent confusion, we'll refrain from delving into all the various variations at this moment.
In summary, our focus will be on the concept of implementing changes to either all four sides or individual sides of the box, commonly referred to as left, right, top, and bottom. Armed with this understanding, let's proceed to our web page and explore the potential of utilizing borders, margins, and padding to effect desired changes.

# Working with Border, Padding and Margin in CSS
Now that we've familiarized ourselves with border padding and margin, it's time to implement that knowledge on our web page.
Currently, there are some issues with the page. The background leaves aren't positioned correctly, and spacing problems are evident. For instance, "H Plus Sport" doesn't align with the top of the web page, and the bars don't extend fully across the page. To address these issues, let's start with the body element, which inherits a default margin from the browser's style sheet. By setting this margin to zero, we can remove it. As for the leaves, which are currently positioned 97% down the page, we want them at the bottom. One solution is to introduce a footer element, transferring the background image from the body to the footer. Additionally, give the footer some height and add a top border to distinguish it from the rest of the page.
Moving on to the headings, by default, headings come with margins that create space above and below the text. To push the H1 to the top of the page, remove its margin. However, this might make the text appear cramped against the edges. To alleviate this, utilize the padding property. Adding a few rems of padding will create a nicely spaced red bar with the text.
For the H2 and H3 headings, remove the background color and introduce it separately. There might be a gap between the H1 and H2 due to margins present on both. Set the top margin of the H2 to zero and apply some padding for visual appeal. Additionally, consider adding a decorative border at the bottom. Regarding the H3, establish a border at the top, incorporate a background color, set appropriate padding, and adjust the margin to align the text.
Within the HTML, there's an image in the middle of the page. To center it, enclose it within a paragraph with a class of "circle" and set the text-align property of the paragraph to center. This ensures the image is effectively centered within the paragraph.
Finally, let's explore the border-radius property, which enables us to round the corners of elements. By assigning a class of "circle-img" to the image and specifying a border-radius value, we can achieve rounded corners. This can be accomplished using pixels or percentages, depending on the desired shape.
Through the application of these CSS adjustments, our page will significantly improve in appearance. With targeted selectors, essential properties, values, and attention to spacing and fonts, we can achieve a well-designed page with minimal CSS.

# Unit 4: Advanced CSS Proprties and Concepts
# Styling Links with CSS
Links play a crucial role in navigating the internet. Typically, they appear as blue and underlined, and once clicked, they turn purple. In this exercise, we're examining the behavior of links in Sublime Text.
Currently, a guest tab in Chrome is being utilized, which doesn't display the visit history for certain courses. Consequently, even though web pages were visited, it seems as if all the links remain unvisited. Let's concentrate on formatting links in HTML and CSS. While changing the color of text on a web page is achievable by specifying a color code, like dc267f, to render headings and bullets in hot pink, the links retain their default blue color (or perhaps blue and purple for some) due to browsers prioritizing their own style sheet over styles applied to the body element. So, how can we style links in a logical manner? Let's delve deeper into that.
The optimal approach is to target links using the "a" anchor tag. By specifying "a" and setting the color to 648fff, a more appealing blue color, this style will affect all links, including visited ones, which will also appear blue. This occurs because the browser's style sheet originally designated blue and purple for links, but our new style overrides that, making everything blue. 
Remember, links have different states, and we can make exceptions for each state.
One common exception is the "a:hover" state, activated when hovering over a link. In this instance, the color can be altered to pink (fe6100), and the underline can be eliminated using "text-decoration: none." Now, when hovering over the links, the color changes and the underline disappears. Previously, achieving this effect without the hover style was not possible. If we remove the hover style, no changes occur when hovering over the links.
What if we want distinct styles for visited and unvisited links? That's achievable too. Define the appealing blue color as the "a:link" style for unvisited links, and the lovely shade of purple (785ef0) as the "a:visited" style for visited links. If there are visited links on the page, they should now display in this pleasant shade of purple. And naturally, the hover style remains intact for when we hover our mouse over the links.
Just remember, the sequence of these styles is crucial. Either use "a" followed by "a:hover," or "a:link," "a:visited," and "a:hover" in that specific order for the styling to function correctly.
Before moving forward, it's worth mentioning something about the underlines on links.
Typically, when links are embedded within lengthy text, retaining the underlines is essential. This aids individuals who may be colorblind or have disabilities that make it challenging to differentiate between the link and the surrounding text. However, if links appear in a navigation bar or any area where users anticipate clicking to be redirected, underlines can be omitted in those specific scenarios. These are just a few straightforward tips to style web page links in an aesthetically pleasing manner.

# Inheritance in CSS
Understanding inheritance and specificity in CSS can be challenging, especially for beginners. While these concepts were briefly introduced in this course, let's delve deeper to provide a clearer understanding of how they function in your CSS.
The web page we're working on is in its earliest version, with a few links added for demonstration purposes. Let's revisit the styling process and discuss what occurs as these styles are applied. Since you're already acquainted with the code, these explanations will likely make more sense to you now.
To begin, let's focus on the "body" element and set the font family to Arial, Helvetica, sans-serif. As anticipated, the entire web page adopts the Arial font. This phenomenon has been observed numerous times, but here's something intriguing: if we add a solid red border of four pixels to the body, we'll notice a single border encircling the web page. While the body element may not be visible in SublimeText's HTML, it does exist just before the H1 and before the closing body tag, at the document's end. What's noteworthy is that despite only specifying the font family for the body, all HTML elements within it inherit the same Arial font.
Why does this happen? Font-related styles typically inherit, which is logical because we aim to maintain consistency throughout the document without a mishmash of different fonts. Thus, when a font is specified for the body, all its contents inherit the same font. Conversely, styles related to the box model, such as borders, usually apply only to the specified element in our style and do not inherit. Imagine the chaos if they did!
Consider an example: if we use the "*" selector, which selects everything on the page, and apply a border to it instead of the body, we end up with a visually overwhelming web page. The "*" selector, as known from other computing areas, selects absolutely everything, resulting in each HTML element being given a border. This chaotic appearance demonstrates what would happen if borders were inherited, emphasizing the importance of containment.
While this idea of inheritance may primarily concern developers rather than the average user, it's crucial to be aware of its implications in CSS styling.

# Debugging CSS with borders and background colors
At times, when you encounter styling issues with CSS, you may find yourself pondering which element to style or why your styles aren't behaving as expected. When confronted with such challenges, debugging techniques can prove to be invaluable.
One useful trick involves adding a background color or a border to the element you wish to style. This can unveil hidden information about its layout and positioning. For instance, consider an example involving an unordered list (UL) in HTML. If you wish to ascertain the exact position of the UL on the page, applying a border to it using a CSS style like "border: 2px solid red" can be illuminating. This border will reveal the full width of the UL, extending across the body element.
Now, let's contrast the UL with the link (A) within the list item (LI). By setting the background color of the link to FFB000, you'll notice that the links are only as wide as their content. This distinction between block and inline elements is crucial. Block elements, such as the UL and LI, occupy the entire width of their container (in this case, the body), whereas inline elements, like the links (A), are constrained to the width of their content. This observation becomes evident in our CSS example.
Suppose you desire a hover effect that spans the entire width of the element but only for the link. You might find yourself puzzled about the behavior at the edges. In such scenarios, changing the A (link) to an LI (list item) can be illuminating since LI is a block-level element, thus spanning the full width. Subsequently, you can apply a hover effect to the LI using the "LI:hover" selector. Observe how the hover effect now covers the entire document width, unlike the link part? The cursor behavior also alters, indicating that clicking is possible only when hovering over the A element. This could be a scenario you're attempting to diagnose‚Äîwhy can't you click at the document's edges? The explanation lies in the fact that you're dealing with a link that's as wide as its text.
There are solutions to address this issue. For more advanced users, a quick fix involves adding the CSS style "display: block" to the A selector, thereby stretching the link across the page. Additionally, defining a hover state for the link using "A:hover" can change the background color and text color accordingly. Now, when hovering over the edges, the hand cursor indicates that the link is clickable, and the hover state encompasses the entire list.
We gradually resolved this problem by experimenting with borders and background colors‚Äîa practical approach when debugging CSS code.
If you're uncertain about how something appears, seeing it is essential for styling it. Simply surrounding it with a border and adding some background colors can provide clarity.
Don't fret if it appears unattractive initially. Focus on ensuring proper functionality first, and then refine the design once functionality is correct.
